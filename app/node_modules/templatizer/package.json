{
  "name": "templatizer",
  "description": "Simple solution for compiling jade templates into vanilla JS functions for blazin' fast client-side use.",
  "version": "1.5.0",
  "author": {
    "name": "Henrik Joreteg",
    "email": "henrik@andyet.net"
  },
  "bin": {
    "templatizer": "./bin/cli"
  },
  "bugs": {
    "url": "https://github.com/HenrikJoreteg/templatizer/issues"
  },
  "contributors": [
    {
      "name": "Beau Sorensen",
      "email": "mail@beausorensen.com"
    },
    {
      "name": "Luke Karrys",
      "email": "luke@andyet.net"
    }
  ],
  "dependencies": {
    "escodegen": "0.0.26",
    "esprima": "^1.2.1",
    "falafel": "^0.3.1",
    "glob": "^4.3.5",
    "jade": "^1.9.2",
    "lodash": "^3.2.0",
    "minimatch": "^2.0.7",
    "minimist": "^0.1.0",
    "uglify-js": "^2.4.0",
    "walkdir": "0.0.7"
  },
  "devDependencies": {
    "browserify": "^3.43.0",
    "colors": "^0.6.0",
    "http-server": "^0.6.1",
    "jshint": "^2.5.0",
    "phantomjs": "^1.9.7-15",
    "precommit-hook": "^1.0.7",
    "requirejs": "^2.1.16",
    "testee": "^0.1.1",
    "underscore": "^1.7.0",
    "yetify": "0.1.0"
  },
  "homepage": "https://github.com/HenrikJoreteg/templatizer",
  "keywords": [
    "browser",
    "jade",
    "templates"
  ],
  "license": "MIT",
  "main": "templatizer.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/HenrikJoreteg/templatizer.git"
  },
  "scripts": {
    "benchmark": "node benchmark/speedtest.js",
    "browserify": "./node_modules/.bin/browserify test/tests-browserify.js > test/tests-browserify-bundle.js",
    "build": "npm run copy-runtime && node build.js",
    "copy-require": "cp node_modules/requirejs/require.js test/require.js",
    "copy-runtime": "cp node_modules/jade/lib/runtime.js jaderuntime.js",
    "copy-underscore": "cp node_modules/underscore/underscore.js test/underscore.js",
    "lint": "jshint .",
    "setup-test": "npm run build && npm run browserify && npm run copy-underscore && npm run copy-require",
    "start": "npm run setup-test && http-server -p 3003 test/",
    "test": "npm run setup-test && testee test/index.html"
  },
  "readme": "# templatizer.js\n\n[![Build Status](https://travis-ci.org/HenrikJoreteg/templatizer.png?branch=master)](https://travis-ci.org/HenrikJoreteg/templatizer)\n\n[![NPM](https://nodei.co/npm/templatizer.png?downloads=true)](https://nodei.co/npm/templatizer/)\n\nSimple solution for compiling jade templates into vanilla JS functions for blazin' fast client-side use.\n\n## What is this?\n\nClient-side templating is overly complicated, ultimately what you *actually* want is a function you can call from your JS that puts your data in a template. Why should I have to send a bunch of strings with Mustaches `{{}}` or other silly stuff for the client to parse? Ultimately, all I want is a function that I can call with some variable to render the string I want.\n\nSo, the question is, what's a sane way to get to that point? Enter [jade](http://jade-lang.com). Simple, intuitive templating, and happens to be what I use on the server anyway. So... Jade has some awesome stuff for compiling templates into functions. I just built templatizer to make it easy to turn a folder full of jade templates into a CommonJS module that exports all the template functions by whatever their file name.\n\n## Is it faster?\nFrom my tests it's 6 to 10 times faster than mustache.js with ICanHaz.\n\n## How do I use it?\n\n1. `npm install templatizer`\n1. Write all your templates as individual jade files in a folder in your project.\n1. Somewhere in your build process do this:\n\n```js\nvar templatizer = require('templatizer');\n\n// pass in the template directory and what you want to\n// save the output file as. That's it!\ntemplatizer(__dirname + '/templates', __dirname + '/demo_output.js', options);\n```\n\nSo a folder like this\n\n```\n/clienttemplates\n   user.jade\n   app.jade\n   /myfolder\n     nestedTemplate.jade\n```\n\nCompiles down to a JS file that looks something like this:\n\n```js\n// here's about 1.6k worth of utils that jade uses to DRY up the template code a bit.\n// Includes some basic shims for Object.keys, etc.\nvar jade=function(exports){ ... }\n\n// a function built from the `user.jade` file\n// that takes your data and returns a string.\nexports.user = function () {}\n\n// built from the `app.jade` file\nexports.app = function () {} // the function\n\n// folders become nested objects so\n// myfolder/nestedTemplate.jade becomes\nexports.myfolder.nestedTemplate = function () {} // the template function\n\n// etc. etc\n```\n\nThe awesome thing is... there are no external dependencies because they're just functions at this point. Crazy fast, SO MUCH WIN!!!!\n\n### Glob Paths\n\nThe directory path can also be a [glob](https://github.com/isaacs/node-glob) instead that can be used to match `*.jade` files across multiple directories. For example:\n\n```js\ntemplatizer(__dirname + '/app/**/*.jade', __dirname + '/templates.js');\n```\n\n### Options\n\nThe third parameter passed to `templatizer` is an options object.\n\n#### `namespace` (object, optional)\n\nIf you are using templatizer as a global in the browser (without requirejs, browserify, or something similar) by default your templates will be available at `window.templatizer`. Using `namespace` you can attach it to a different global object or rename the property it attaches to.\n\n#### `namespace.parent` (string, default `window`)\n\nThis is the name of the object where you want to attach your templates.\n\n#### `namespace.defineParent` (boolean, default `false`)\n\nIf this option is `true` and `namespace.parent` does not exist, it will be created. By default if `namespace.parent` does not exist, templatizer will throw an error like this: `templatizer: window.app does not exist or is not an object`.\n\n#### `namespace.name` (string, default `templatizer`)\n\nThis is the name of the property on `namespace.parent` where your templates will be attached.\n\n#### Shorthand\n\nIf all you want is to attach the `templatizer` object to an already created global variable, then you can just make `namespace` the name of the object where it will attach:\n\n\n```js\ntemplatizer(templatesDir, 'templates.js', {\n    namespace: 'app'\n});\n```\n\n```html\n<script>var app = {};</script>\n<script src=\"templates.js\"></script>\n<script>\n  // Templates will be available on app.templatizer\n  document.body.innerHTML = app.templatizer.body();\n</script>\n```\n\n#### `dontRemoveMixins` (boolean, default false)\n\nBy default `jade` will not compile any mixins which aren't being called from the file they were created in. This is usually a very good thing, since keeps file sizes down. But in some cases (especially when using the [mixin support](#mixin-support) functionality), you may want to create mixins and call them from other places in your code or other files. Setting this option to `true` will keep all mixins in the compiled source.\n\n#### `inlineJadeRuntime` (boolean, default true)\n\nBy default the jade runtime will be included into the generated template javascript file. In order minimize the file size you can set this parameter to false. Instead a `jade` module is expected as amdDependency parameter. Otherwise an error will be thrown.\n\n#### `amdDependencies` (array, default [])\n\nAn array of AMD module dependencies you want to pass in to the generated templates javascript file. \n\n#### `jade` (object, default `{}`)\n\n`jade` is an object which will be passed directly to `jade.compile()`. See the [Jade API documentation](http://jade-lang.com/api/) for what options are available.\n\nHere's an example where we set the Jade `compileDebug` option to `true`.\n\n```js\ntemplatizer(templatesDir, outputFile, {\n    // Options\n    jade: {\n        compileDebug: true\n    }\n});\n```\n\n#### `globOptions` (object, default `{}`)\n\n`globOptions` will be passed directly to `node-glob`. See the [API docs](https://github.com/isaacs/node-glob#options) for available options.\n\n### Mixin Support\n\nJade has a feature called `mixins` which when compiled get treated as function declarations within the compiled function. Templatizer pulls these out of the compiled function and places them on the namespace of the parent function. For example:\n\n```jade\n// users.jade\nul\n    each user in users\n        mixin user(user)\n\nmixin user(user)\n    // Jade mixin content\n```\n\nTemplatizer will compile this as\n\n```js\n// Compiled fn from file\nexports.users = function () {}\n\n// Compiled mixin fn\nexports.users.user = function (user) {}\n```\n\nThis is helpful as it allows you to call `users()` to create your list and then `users.user()` to render just a single item in the list.\n\n## CLI\n\nTemplatizer comes with a bin script to use from makefiles/package.json scripts/etc, it works like this:\n\n```\n$ templatizer -d path/to/templates -o /path/to/output/templates.js\n```\n\n## Tests\n\nRun `npm test` to run the tests (you'll need phantomjs installed). You can also run the tests in your browser with `npm run browser-test` and going to [http://localhost:3003](http://localhost:3003).\n\n## Changelog\n\n- v0.2.9 [diff](https://github.com/henrikjoreteg/templatizer/compare/v0.2.8...v0.2.9) - Adding path normalize to avoid issues if passing in paths like `/thing/../otherfolder`.\n\n## License\n\nMIT\n\n## Contributors\n\n- Aaron McCall [github profile](https://github.com/aaronmccall)\n- Luke Karrys [github profile](https://github.com/lukekarrys)\n\nIf you think this is cool, you should follow me on twitter: [@HenrikJoreteg](http://twitter.com/henrikjoreteg)\n",
  "readmeFilename": "README.md",
  "_id": "templatizer@1.5.0",
  "_from": "templatizer@^1.0.0"
}
