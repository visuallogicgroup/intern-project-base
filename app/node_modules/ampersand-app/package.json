{
  "name": "ampersand-app",
  "description": "Simple instance store for managing instances without circular dependency issues in ampersand apps.",
  "version": "1.0.4",
  "author": {
    "name": "Henrik Joreteg",
    "email": "henrik@andyet.net"
  },
  "bugs": {
    "url": "https://github.com/ampersandjs/ampersand-app/issues"
  },
  "homepage": "https://github.com/ampersandjs/ampersand-app",
  "keywords": [
    "instance store",
    "object store"
  ],
  "license": "MIT",
  "main": "ampersand-app.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/ampersandjs/ampersand-app"
  },
  "scripts": {
    "test": "node test/index.js",
    "test-browser": "zuul --local 8080 -- test/index.js",
    "test-ci": "zuul -- test/index.js"
  },
  "dependencies": {
    "ampersand-events": "^1.0.1",
    "ampersand-version": "^1.0.2",
    "lodash.assign": "^3.1.0",
    "lodash.toarray": "^3.0.1"
  },
  "browserify": {
    "transform": [
      "ampersand-version"
    ]
  },
  "devDependencies": {
    "amp-keys": "^1.0.1",
    "tape": "^3.4.0",
    "zuul": "^1.16.5"
  },
  "readme": "# ampersand-app\n\n<!-- starthide -->\nPart of the [Ampersand.js toolkit](http://ampersandjs.com) for building clientside applications.\n<!-- endhide -->\n\nSimple instance store and event channel that allows different modules within your app to communicate without requiring each other directly. The entire module is only ~30 lines of code, you can [read the source here](https://github.com/AmpersandJS/ampersand-app/blob/master/ampersand-app.js) to see exactly what it does.\n\n\n## The Singleton pattern\n\nWhenever you `require('ampersand-app')` it returns *the same instance of a plain 'ol JavaScript `Object`*.\n\nThis is called the [Singleton pattern](http://en.wikipedia.org/wiki/Singleton_pattern). \n\nThis object it returns is nothing special. It's just a plain old JavaScript `Object` that has been decorated with [ampersand-events](http://ampersandjs.com/docs#ampersand-events) methods as well as an `extend` and `reset` method.\n\nThat's it!\n\n\n## Why is this useful?\n\nIt's quite common to create an `app` global to store collections and models on and then to reference that global whenever you need to look up related model instance from another module within your app. However, this creates many indirect interdependencies within your application which makes it more difficult to test isolated parts of your application. \n\nIt's also quite common to need \"application-level\" events that any number of pieces of your app may need to handle. For example, navigation events, or error events that could be triggered by any number of things within your app but that you want to handle by a single module that shows them as nice error dialogs.\n\nThis module provides a pattern to address both those cases without having to rely on globals, or have circular dependency issues within your apps. It also means you don't have to adjust code linting rules to ignore that `app` global.\n\n\n**Before `ampersand-app`**\n\nModule \"A\" (app.js):\n\n```javascript\nvar MyModel = require('./models/some-model');\n\n// explicitly create global\nwindow.app = {\n    init: function () {\n        this.myModel = new MyModel();\n    }\n};\n\nwindow.app.init();\n```\n\nModule \"B\" (that needs access to `app`):\n\n```javascript\n// note we're not requiring anything\nmodule.exports = View.extend({\n    someMethod: function () {\n        // reference app and models directly\n        app.myModel.doSomething():\n    }\n});\n```\n\n**With `ampersand-app` you'd do this instead:**\n\nModule \"A\" (app.js):\n\n```javascript\n// it just requires ampersand-app too!\nvar app = require('ampersand-app');\nvar MyModel = require('./models/some-model');\n\n// Here we could certainly *chose* to attach it to\n// window for better debugging in the browser \n// but it's no longer necessary for accessing the \n// app instance from other modules.\napp.extend({\n    init: function () {\n        this.myModel = new MyModel();\n    }\n};\n\napp.init();\n```\n\nModule \"B\" (that needs access to `app`):\n\n```javascript\n// this just requires ampersand-app too!\nvar app = require('ampersand-app');\n\n\nmodule.exports = View.extend({\n    someMethod: function () {\n        // reference app that we required above\n        app.myModel.doSomething():\n\n        // now as a bonus, since `app` supports events\n        // we've also got a global \"pubsub\" mechanism\n        // for app events, that any other modules can \n        // listen to.\n        app.trigger('some custom event');\n    }\n});\n```\n\nNow when we go to write tests for module \"B\" we can easily mock things that it expects from `app`. \n\nSo our tests for module B might look like this:\n\n```js\nvar test = require('tape');\nvar ModuleB = require('../module-b');\n// note we just require ampersand-app here\n// and make sure it has what module b expects\nvar app = require('ampersand-app');\n\n\ntest('test module B', function (t) {\n    // each test can clear it.\n    app.reset();\n    // stub out what it might need for the\n    // test.\n    app.myModel = {\n        doSomething: function () {}\n    };\n\n    // check to make sure calling \n    // `someMethod` fires event on app\n    app.on('some custom event', function () {\n        t.pass('custom event fired');\n\n        // app also has a `reset` for testing\n        // purposes that purges it to start over\n        // so this could be used to reset before each test\n        app.reset();\n\n        t.end();\n    });\n\n    var view = new ModuleB();\n    \n    t.doesNotThrow(function () {\n        view.someMethod();\n    }, 'make sure calling some method does not explode');\n});\n\ntest('next test', function () {\n    // now we can use `reset` if we want\n    // to make sure we clear that state\n    app.reset();\n\n    // etc. etc.\n});\n```\n\n\n## Warning: Not for use in re-usable modules\n\n**If you're writing a re-usable module for distribution on [npm](http://npmjs.org/) it should not have `ampersand-app` as a dependency.**\n\nDoing so makes assumptions about how you want it to be used.\n\nSay you want to make an `error` event handling module, that requires `ampersand-app` listens for `error` events from that `app` and shows a nice error dialog. \n\nRather than make all those assumptions about how its going to be used, just make the nice error dialog view and suggest in the readme how someone might use `ampersand-app` as an event channel to trigger them.\n\nThis allows people who don't use this particular application pattern to still use your npm module and leaves the event names, and application architecture up to the person building the app.\n\n\n## install\n\n```\nnpm install ampersand-app\n```\n\n## API Reference\n\n### event methods\n\nThe `app` object is an event object so it contains all the methods as described in the [ampersand-events docs](http://ampersandjs.com/docs#ampersand-events).\n\nThe `app` object becomes a handy way to communicate within your app so various modules can notify each other about \"app-level\" events such as user navigation, etc.\n\n### extend `app.extend(obj, [*objs])`\n\nConvenience method for attaching multiple things to the app at once. This is simply an alias for `amp-extend` that pre-fills the `app` as the object being extended.\n\n* `obj` {Object} copy properties from this object onto `app`. You can pass as many objects to this as you want as additional arguments.\n\n```javascript\nvar app = require('ampersand-app');\nvar UserCollection = require('./models/user-collection');\nvar MeModel = require('./models/me');\n\n\napp.extend({\n    me: new MeModel(),\n    users: new UserCollection(),\n    router: new Router(),\n    init: function () {\n        this.router.history.start({pushState: true});\n    }\n});\n```\n\n### reset `app.reset()`\n\nResets the app singleton to its original state, clearing all listeners, and deleting everything you've added to it, but keeping the same object instance.\n\nThis is primarily for simplifying unit testing of modules within your app. Whenever you `require('ampersand-app')` you get the same object instance (this is the [Singleton pattern](http://en.wikipedia.org/wiki/Singleton_pattern)). So, having `app.reset()` lets you mock app state required for testing a given module.\n\n<!-- starthide -->\n## credits\n\nCreated by [@HenrikJoreteg](http://twitter.com/henrikjoreteg).\n\n## license\n\nMIT\n<!-- endhide -->\n",
  "readmeFilename": "README.md",
  "_id": "ampersand-app@1.0.4",
  "_from": "ampersand-app@^1.0.0"
}
