{
  "name": "ampersand-collection",
  "version": "1.4.5",
  "author": {
    "name": "Henrik Joreteg",
    "email": "henrik@andyet.net"
  },
  "bugs": {
    "url": "https://github.com/ampersandjs/ampersand-collection/issues"
  },
  "files": [
    "ampersand-collection.js"
  ],
  "dependencies": {
    "ampersand-class-extend": "^1.0.0",
    "ampersand-events": "^1.0.1",
    "lodash.assign": "^3.0.0",
    "lodash.bind": "^3.1.0",
    "lodash.isarray": "^3.0.1"
  },
  "devDependencies": {
    "ampersand-state": "^4.4.5",
    "precommit-hook": "0.x.x",
    "run-browser": "^1.3.1",
    "tap-spec": "^0.2.1",
    "tape": "2.x.x"
  },
  "homepage": "https://github.com/ampersandjs/ampersand-collection",
  "keywords": [
    "collection",
    "client",
    "mvc"
  ],
  "license": "MIT",
  "main": "ampersand-collection.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/ampersandjs/ampersand-collection"
  },
  "scripts": {
    "start": "run-browser test/*",
    "test": "node test/main.js | tap-spec"
  },
  "testling": {
    "files": "test/*.js",
    "browsers": [
      "ie/9..latest",
      "firefox/17..latest",
      "firefox/nightly",
      "chrome/22..latest",
      "chrome/canary",
      "opera/12..latest",
      "opera/next",
      "safari/5.1..latest",
      "ipad/6.0..latest",
      "iphone/6.0..latest",
      "android-browser/4.2..latest"
    ]
  },
  "readme": "# ampersand-collection\n\nA way to store/manage objects or models.\n\nUnlike other tools this makes no assumptions about how it's going to be used or what type of models it is going to contain. This makes it a very flexible/useful tool for modeling all kinds of stuff.\n\nIt does not require underscore or jQuery, but instead makes it easy to extend with those methods if you'd like.\n\n<!-- starthide -->\nPart of the [Ampersand.js toolkit](http://ampersandjs.com) for building clientside applications.\n<!-- endhide -->\n\n<!-- starthide -->\n## browser support\n\n[![browser support](https://ci.testling.com/ampersandjs/ampersand-collection.png)\n](https://ci.testling.com/ampersandjs/ampersand-collection)\n<!-- endhide -->\n\n## Installation\n\n```\nnpm i ampersand-collection\n```\n\n<!-- starthide -->\n## massive flexibility\n\nThe collection is a fairly low-level tool, in that it's useful for any time you want to be able to store JS objects in an array.\n\nIn many ways it's simply an observable array of objects.\n\nIt emits events when models are added, removed, sorted and more. It also allows for merging in a set of objects into an existing collection and emitting change events appropriately. For a detailed overview of the events that are emitted by ampersand-collection, please refer to the [Event Catalog](http://ampersandjs.com/learn/events) on the AmpersandJS learn page.\n\nIf you extend it with a `.model` property that contains a constructor, the collection will ensure that objects that don't match that constructor are instantiated before being added to the collection.\n\nFor example:\n\n```js\nvar Collection = require('ampersand-collection');\n\n// can just store plain objects\nvar basicCollection = new Collection([\n    {name: 'larry'},\n    {name: 'curly'},\n    {name: 'moe'}\n]);\n```\n\nAdding [ampersand-collection-rest-mixin](https://github.com/AmpersandJS/ampersand-collection-rest-mixin) and [ampersand-collection-underscore-mixin](http://github.com/AmpersandJS/ampersand-collection-underscore-mixin). \n\n```js\nvar Collection = require('ampersand-collection');\nvar restMixin = require('ampersand-collection-rest-mixin');\nvar underscoreMixin = require('ampersand-collection-underscore-mixin');\n\n\n// or we can extend it with underscore and REST methods\n// to turn it into something similar to a Backbone Collection\nvar RestfulCollection = Collection.extend(underscoreMixin, restMixin, {\n    url: '/mystuff'\n});\n\nvar collection = new RestfulCollection();\n\n// does ajax request\ncollection.fetch();\n```\n\n## A quick note about `instanceof` checks\n\nBecause of module deps in npm and browserify, sometimes it’s possible to end up in a situation where the same `collection` constructor wasn't used to build a `collection` object. As a result, `instanceof` checks will fail. \n\nTo deal with this (because sometimes this is a legitimate scenario), `collection` simply creates a read-only `isCollection` property on all collection objects. You can use it to check whether or a not a given object is, in fact, a collection object—no matter what its constructor was.\n<!-- endhide -->\n\n## API Reference\n\n### extend `AmpersandCollection.extend([attributes])`\n\nCreate a collection class of your own by extending `AmpersandCollection`, providing the required instance properties to be attached instances of your class.\n\nTypically you will specify a `model` constructor (if you are storing [ampersand-state](#ampersand-state) or [ampersand-model](#ampersand-model) objects).\n\n### model `collection.model`\n\nOverride this property to specify the model class that the collection contains. If defined, you can pass raw attributes objects (and arrays) to `add` and `reset`, and the attributes will be converted into a model of the proper type.\n\n```javascript\nvar Library = AmpersandCollection.extend({\n    model: Book\n});\n```\n\nA collection can also contain polymorphic models by overriding this property with a function that returns a model.\n\n*Please note* that if you do this, you'll also want to override the `isModel` method with your own, and describe the logic used to determine whether an object is already an instantiated model or not.\n\n```javascript\nvar Library = AmpersandCollection.extend({\n\n  model: function(attrs, options) {\n    if (condition) {\n      return new PublicDocument(attrs, options);\n    } else {\n      return new PrivateDocument(attrs, options);\n    }\n  },\n\n  isModel: function (model) {\n    return model instanceof PublicDocument || model instanceof PrivateDocument;\n  }\n\n});\n```\n\n\n### constructor/initialize `new AmpersandCollection([models], [options])`\n\nWhen creating an `AmpersandCollection`, you may choose to pass in the initial array of **`models`**. The collection's [`comparator`](#comparator) may be included as an option. If you define an **`initialize`** function, it will be invoked when the collection is created. There are a couple of options that, if provided, are attached to the collection directly: `model`, `comparator` and `parent`.\n\n```javascript\nvar people = new AmpersandCollection([{ name: 'phil' }, { name: 'bob' }, { name: 'jane' }], {\n    model: Person\n});\n```\n\n### mainIndex `collection.mainIndex`\n\nSpecify which property the collection should use as the main index (and unique identifier) for the models/objects it holds. This is the property that [`get`](#ampersand-collection-get) uses to retrieve models, and what `add`, `set`, and `remove` uses to determine whether a collection already contains a model or not. \n\nIf you specify a [`model`](http://ampersandjs.com/docs#ampersand-collection-model) property in the collection, and the model specifies an [`idAttribute`](http://ampersandjs.com/docs#ampersand-state-idattribute), the collection will use *that* as the `mainIndex` unless you explicitly set it to something else.\n\nIf *no* `mainIndex` or `model` is specified `\"id\"` is used as the default `mainIndex`.\n\nThis means, that *most* of the time you don't need to set `mainIndex` and things will still Just Work™.\n\nBut if you wish, you may set it while extending `AmpersandCollection` like so:\n\n```javascript\nvar People = AmpersandCollection.extend({\n    mainIndex: '_id'\n});\n```\n\n### indexes `collections.indexes`\n\nSpecify an optional array of keys to serve as additional indexes for the models in your collection (in addition to `mainIndex`). This allows you to quickly retrieve models by specifying the key to use with [`get`](#ampersand-collection-get).\n\nNote that `get` will only ever return a single model, so the values of these indexes should be unique across the models in the collection:\n\n```javascript\nvar People = AmpersandCollection.extend({\n    mainIndex: '_id',\n\n    indexes: ['otherId']\n});\n\nvar people = new People.add([\n    { _id: 1, otherId: 'a', name: 'Phil' },\n    { _id: 2, otherId: 'b', name: 'Julie' },\n    { _id: 3, otherId: 'c', name: 'Henrik' },\n    { _id: 4, otherId: 'd', name: 'Jenn' }\n]);\n\npeople.get(1) //=> { _id: 1, otherId: 'a', name: 'Phil' }\n\npeople.get('b', 'otherId') //=> { _id: 2, otherId: 'b', name: 'Julie' },\n```\n\n\n### length `collection.length`\n\nReturns the `length` of the underlying array.\n\n\n### isCollection/instanceof `collection.isCollection`\n\nBecause of module deps in npm and browserify, sometimes it’s possible to end up in a situation where the same `collection` constructor wasn't used to build a `collection` object. As a result, `instanceof` checks will fail. \n\nTo deal with this (because sometimes this is a legitimate scenario), `collection` simply creates a read-only `isCollection` property on all collection objects. You can use it to check whether or a not a given object is, in fact, a collection object—no matter what its constructor was.\n\n\n### add `collection.add(modelOrObject, [options])`\n\nAdd a model (or an array of models) to the collection, firing an `\"add\"` event. If a [`model`](#ampersand-collection-model) property is defined, you may also pass raw attributes objects, and have them be vivified as instances of the model. Returns the added models (or preexisting models, if already contained).\n\n**Options:**\n\n* Pass `{at: index}` to splice the model into the collection at the specified index.\n* If you're adding models to the collection that it already contains, they'll be ignored, unless you pass `{merge: true}`, in which case their attributes will be merged into the corresponding models, firing any appropriate `\"change\"` events.\n\n```javascript\nvar ships = new AmpersandCollection();\n\nships.on(\"add\", function(ship) {\n  console.log(\"Ahoy \" + ship.name + \"!\");\n});\n\nships.add([\n  {name: \"Flying Dutchman\"},\n  {name: \"Black Pearl\"}\n]);\n\n//logs:\n//- \"Ahoy Flying Dutchman!\"\n//- \"Ahoy Black Pearl!\"\n```\n\nNote that adding the same model (a model with the same `id`) to a collection more than once is a no-op.\n\n\n### serialize `collection.serialize()`\n\nSerialize the collection into a plain javascript array, ready for sending to the server (typically called via [`toJSON`](#ampersand-collection-tojson)). Also calls `serialize()` on each model in the collection.\n\n### toJSON `collection.toJSON()`\n\nReturns a plain javascript array of the models in the collection (which are also serialized), ready for sending to the server. The name of this method is a bit confusing, as it doesn't actually return a JSON string — but I'm afraid that it's the way that the JavaScript API for `JSON.stringify()` works.\n\n```javascript\nvar collection = new AmpersandCollection([\n    {name: \"Tim\", age: 5},\n    {name: \"Ida\", age: 26},\n    {name: \"Rob\", age: 55}\n]);\n\nconsole.log(JSON.stringify(collection));\n//=> \"[{\\\"name\\\":\\\"Tim\\\",\\\"age\\\":5},{\\\"name\\\":\\\"Ida\\\",\\\"age\\\":26},{\\\"name\\\":\\\"Rob\\\",\\\"age\\\":55}]\"\n```\n\n\n### set `collection.set(models, [options])`\n\nThe **set** method performs a \"smart\" update of the collection with the passed list of models: \n\n* If a model in the list isn't in the collection, it will be added. \n* If a model in the list is in the collection already, its attributes will be merged. \n* If the collection contains any models that aren't in the list, they'll be removed. \n\nAll of the appropriate `\"add\"`, `\"remove\"`, and `\"change\"` events are fired as this happens. If you'd like to customize the behavior, you can disable it with options: `{add: false}`, `{remove: false}`, or `{merge: false}`.\n\nReturns the touched models in the collection.\n\n```javascript\nvar vanHalen = new AmpersandCollection([eddie, alex, stone, roth]);\n\nvanHalen.set([eddie, alex, stone, hagar]);\n\n// Fires a \"remove\" event for roth, and an \"add\" event for \"hagar\".\n// Updates any of stone, alex, and eddie's attributes that may have\n// changed over the years.\n```\n\n### get `collection.get(query, [indexName])`\n\nRetrieve a model from the collection by index.\n\nIf called without `indexName` (`collection.get(123)`), retrieves the model by its [`mainIndex`](#ampersand-collection-mainindex) attribute.\n\nAlternatively, specify an `indexName` to retrieve a model by any of the other listed [`indexes`](#ampersand-collection-indexes).\n\n```javascript\nvar People = AmpersandCollection.extend({\n    mainIndex: '_id',\n\n    indexes: ['otherId']\n});\n\nvar people = new People.add([\n    { _id: 1, otherId: 'a', name: 'Phil' },\n    { _id: 2, otherId: 'b', name: 'Julie' },\n    { _id: 3, otherId: 'c', name: 'Henrik' },\n    { _id: 4, otherId: 'd', name: 'Jenn' }\n]);\n\npeople.get(1) //=> { _id: 1, otherId: 'a', name: 'Phil' }\n\npeople.get('b', 'otherId') //=> { _id: 2, otherId: 'b', name: 'Julie' },\n```\n\n\n### at `collection.at(index)`\n\nGet a model from a collection, specified by `index`. Useful if your collection is sorted. \n\nIf your collection isn't sorted, `at()` will still retrieve models in insertion order; e.g., `collection.at(0)` returns the first model in the collection.\n\n### remove `collection.remove(models, [options])`\n\nRemove a model (or an array of models) from the collection, and returns them. Fires a `\"remove\"` event, which you can use the option `{ silent: true }` to suppress. The model's index before removal is available to listeners as `options.index`.\n\nThe models object/array can be references to actual models, or just a list of `id`s to remove.\n\n\n### reset `collection.reset(models, [options])`\n\nAdding and removing models one at a time is all well and good, but sometimes there are so many models to change that you'd rather just update the collection in bulk. Use **`reset()`** to replace a collection with a new list of models (or attribute hashes), triggering a single `\"reset\"` event at the end. For convenience, within a `\"reset\"` event, the list of any previous models is available as `options.previousModels`.\n\nReturns the newly-set models. \n\nCalling `collection.reset()` without passing any models as arguments will empty the entire collection.\n\n### sort `collection.sort([options])`\n\nForce a collection to re-sort itself. Triggers a `\"sort\"` event on the collection. \n\nYou don't need to call this under normal circumstances, as a collection with a `comparator` will sort itself whenever a model is added. To prevent this when adding a model, pass a `{sort: false}` option to `add()`.\n\n\n### models `collection.models`\n\nRaw access to the JavaScript array of models inside of the collection. Usually you'll want to use `get`, `at`, or the [proxied array methods](#ampersand-collection-proxied-es5-array-methods-9) to access model objects, but occasionally a direct reference to the array is desired.\n\n### comparator\n\nThe `comparator` option lets you define how models in a collection are sorted. There's a few ways to declare `comparator`:\n\n* Passing `false` prevents sorting\n* Passing `string` sorts the collection by a specific model attribute\n* Passing `function` will use native array `sort` function; which you can define with either 1 argument (each model one by one), or multiple arguments (which lets you write custom compare functions with next 2 models as arguments).\n\n### proxied ES5 array methods (9)\n\nThe base `AmpersandCollection` proxies some basic ES5 methods to the underlying model array. Further documentation of these methods is available at [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#Iteration_methods)\n\n* indexOf\n* lastIndexOf\n* every\n* some\n* forEach\n* each (alias for forEach)\n* map\n* filter\n* reduce\n* reduceRight\n\nUnlike Backbone collections, it does not include Underscore and all of its array methods. But if you want more functions than those built into modern browsers, you can mixin [`ampersand-collection-underscore-mixin`](https://github.com/AmpersandJS/ampersand-collection-underscore-mixin) to get them.\n\n```javascript\nvar people = People([\n    { name: 'Phil', hatColor: 'red' },\n    { name: 'Jenn', hatColor: 'green' },\n    { name: 'Henrik', hatColor: 'blue' },\n    { name: 'Julie', hatColor: 'yellow' }\n]);\n\npeople.map(function (person) { return person.name; }) //=> ['Phil', 'Jenn', 'Henrik', 'Julie']\n\npeople.filter(function (person) {\n    return person.name[0] === 'J';\n}) //=> ['Jenn', 'Julie']\n```\n\n\n<!-- starthide -->\n\n## credits\n\nCreated by [@HenrikJoreteg](http://twitter.com/henrikjoreteg), but many ideas and some code (especially for `set()`) should be credited to Jeremy Ashkenas and the rest of the Backbone.js authors. \n\n\n## license\n\nMIT\n\n<!-- endhide -->\n",
  "readmeFilename": "README.md",
  "description": "A way to store/manage objects or models.",
  "_id": "ampersand-collection@1.4.5",
  "_from": "ampersand-collection@^1.4.5"
}
