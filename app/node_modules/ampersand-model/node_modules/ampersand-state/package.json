{
  "name": "ampersand-state",
  "description": "An observable, extensible state object with derived watchable properties.",
  "version": "4.5.6",
  "author": {
    "name": "Henrik Joreteg",
    "email": "henrik@andyet.net"
  },
  "files": [
    "ampersand-state.js"
  ],
  "browserify": {
    "transform": [
      "ampersand-version"
    ]
  },
  "bugs": {
    "url": "https://github.com/ampersandjs/ampersand-state/issues"
  },
  "dependencies": {
    "ampersand-events": "^1.1.1",
    "ampersand-version": "^1.0.0",
    "array-next": "~0.0.1",
    "key-tree-store": "^1.2.0",
    "lodash.assign": "^3.0.0",
    "lodash.bind": "^3.1.0",
    "lodash.clone": "^3.0.1",
    "lodash.defaults": "^3.1.0",
    "lodash.escape": "^3.0.0",
    "lodash.foreach": "^3.0.2",
    "lodash.has": "^3.0.0",
    "lodash.includes": "^3.1.0",
    "lodash.isarray": "^3.0.1",
    "lodash.isdate": "^3.0.1",
    "lodash.isempty": "^3.0.1",
    "lodash.isequal": "^3.0.1",
    "lodash.isfunction": "^3.0.2",
    "lodash.isnull": "^3.0.0",
    "lodash.isobject": "^3.0.1",
    "lodash.isstring": "^3.0.1",
    "lodash.isundefined": "^3.0.0",
    "lodash.keys": "^3.0.5",
    "lodash.omit": "^3.1.0",
    "lodash.result": "^3.0.0",
    "lodash.union": "^3.1.0",
    "lodash.uniqueid": "^3.0.0"
  },
  "devDependencies": {
    "ampersand-collection": "^1.3.2",
    "ampersand-registry": "0.x.x",
    "browserify": "^5.9.1",
    "jshint": "^2.5.3",
    "phantomjs": "^1.9.7-15",
    "precommit-hook": "^1.0.7",
    "run-browser": "~1.2.0",
    "tap-spec": "^0.2.0",
    "tape": "~2.12.1",
    "tape-run": "^0.2.0"
  },
  "homepage": "https://github.com/ampersandjs/ampersand-state",
  "keywords": [
    "model",
    "object",
    "observable"
  ],
  "license": "MIT",
  "main": "ampersand-state.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/ampersandjs/ampersand-state"
  },
  "scripts": {
    "test": "browserify test/index.js | tape-run | tap-spec",
    "validate": "jshint .",
    "start": "run-browser test/index.js"
  },
  "testling": {
    "files": "test/*.js",
    "browsers": [
      "ie/9..latest",
      "firefox/17..latest",
      "firefox/nightly",
      "chrome/22..latest",
      "chrome/canary",
      "opera/12..latest",
      "opera/next",
      "safari/5.1..latest",
      "ipad/6.0..latest",
      "iphone/6.0..latest",
      "android-browser/4.2..latest"
    ]
  },
  "readme": "# ampersand-state\n\n<!-- starthide -->\nPart of the [Ampersand.js toolkit](http://ampersandjs.com) for building clientside applications.\n<!-- endhide -->\n\nAn observable, extensible state object with derived watchable properties.\n\nAmpersand-state serves as a base object for [ampersand-model](http://github.com/ampersandjs/ampersand-model) but is useful any time you want to track complex state.\n\n[ampersand-model](https://github.com/ampersandjs/ampersand-model) extends ampersand-state to include assumptions that you'd want if you're using models to model data from a REST API. But by itself ampersand-state is useful for anytime you want something to model state, that fires events for changes and lets you define and listen to derived properties.\n\nFor further explanation see the [learn ampersand-state](http://ampersandjs.com/learn/state) guide.\n\n## Install\n\n```\nnpm install ampersand-state --save\n```\n\n## API Reference\n\n### extend `AmpersandState.extend({ })`\n\nTo create a **State** class of your own, you extend **AmpersandState** and provide instance properties and options for your class. Typically here you will pass any properties (`props`, `session` and `derived`) of your state class, and any instance methods to be attached to instances of your class.\n\n**extend** correctly sets up the prototype chain, so that subclasses created with **extend** can be further extended as many times as you like.\n\nDefinitions like `props`, `session`, `derived` etc will be merged with superclass definitions.\n\n```javascript\nvar Person = AmpersandState.extend({\n    props: {\n        firstName: 'string',\n        lastName: 'string'\n    },\n    session: {\n        signedIn: ['boolean', true, false],\n    },\n    derived: {\n        fullName: {\n            deps: ['firstName', 'lastName'],\n            fn: function () {\n                return this.firstName + ' ' + this.lastName;\n            }\n        }\n    }\n});\n```\n\n`AmpersandState.extend` does more than just copy attributes from one prototype to another. As such it is incompatible with Coffeescript's class-based extend. TypeScript users may have similar issues.\n\nFor instance, this will not work since it never actually calls `AmpersandState.extend`:\n\n```\nclass Foo extends AmpersandView\n     constructor: (options)->\n         @special = options.special\n         super\n```\n\n\n### constructor/initialize `new AmpersandState([attrs], [options])`\n\nWhen creating an instance of a state object, you can pass in the initial values of the **attributes** which will be [set](#ampersand-state-set) on the state. Unless [extraProperties](#amperand-state-extra-properties) is set to `allow`, you will need to have defined these attributes in `props` or `session`.\n\nIf you have defined an `initialize` function for your subclass of State, it will be invoked at creation time.\n\n```javascript\nvar me = new Person({\n    firstName: 'Phil'\n    lastName: 'Roberts'\n});\n\nme.firstName //=> Phil\n```\n\nAvailable options:\n\n* `[parse]` {Boolean} - whether to call the class's [parse](#ampersand-state-parse) function with the initial attributes. _Defaults to `false`_.\n* `[parent]` {AmpersandState} - pass a reference to a state's parent to store on the state.\n\n### idAttribute `state.idAttribute`\n\nThe attribute that should be used as the unique id of the state. `getId` uses this to determine the `id` for use when constructing a model's `url` for saving to the server.\n\nDefaults to `'id'`.\n\n```\nvar Person = AmpersandModel.extend({\n    idAttribute: 'personId',\n    urlRoot: '/people',\n    props: {\n        personId: 'number',\n        name: 'string'\n    }\n});\n\nvar me = new Person({ personId: 123 });\n\nconsole.log(me.url()) //=> \"/people/123\"\n```\n\n### getId `state.getId()`\n\nGet ID of state per `idAttribute` configuration. Should *always* be how ID is determined by other code.\n\n### namespaceAttribute `state.namespaceAttribute`\n\nThe property name that should be used as a namespace. Namespaces are completely optional, but exist in case you need to make an additional distinction between states, that may be of the same type, with potentially conflicting IDs but are in fact different.\n\nDefaults to `'namespace'`.\n\n### getNamespace `state.getNamespace()`\n\nGet namespace of state per `namespaceAttribute` configuration. Should *always* be how namespace is determined by other code.\n\n### typeAttribute\n\nThe property name that should be used to specify what type of state this is. This is optional, but specifying a state type types provides a standard, yet configurable way to determine what type of state it is.\n\nDefaults to `'modelType'`.\n\n### getType `state.getType()`\n\nGet type of state per `typeAttribute` configuration. Should *always* be how type is determined by other code.\n\n### extraProperties `AmpersandState.extend({ extraProperties: 'allow' })`\n\nDefines how properties that aren't defined in `props`, `session` or `derived` are handled. May be set to `'allow'`, `'ignore'` or `'reject'`.\n\nDefaults to `'ignore'`.\n\n```javascript\nvar StateA = AmpersandState.extend({\n    extraProperties: 'allow',\n});\n\nvar stateA = new StateA({ foo: 'bar' });\nstateA.foo === 'bar' //=> true\n\n\nvar StateB = AmpersandState.extend({\n    extraProperties: 'ignore',\n});\n\nvar stateB = new StateB({ foo: 'bar' });\nstateB.foo === undefined //=> true\n\n\nvar stateC = AmpersandState.extend({\n    extraProperties: 'reject'\n});\n\nvar stateC = new StateC({ foo: 'bar' })\n//=> TypeError('No foo property defined on this state and extraProperties not set to \"ignore\" or \"allow\".');\n```\n\n### collection `state.collection`\n\nA reference to the collection a state is in, if in a collection.\n\nThis is used for building the default `url` property, etc.\n\nWhich is why you can do this:\n\n```js\n// some ampersand-rest-collection instance\n// with a `url` property\nwidgets.url //=> '/api/widgets'\n\n// get a widget from our collection\nvar badWidget = widgets.get('47');\n\n// Without a `collection` reference this\n// widget wouldn't know what URL to build\n// when calling destroy\nbadWidget.destroy(); // does a DELETE /api/widgets/47\n```\n\n### cid `state.cid`\n\nA special property of states, the **`cid`**, or a client id, is a unique identifier automatically assigned to all states when they are first created. Client ids are handy when the state has not been saved to the server, and so does not yet have its true `id`, but needs a unique id (so it can be rendered in the UI, etc.).\n\n```javascript\nvar userA = new User();\nconsole.log(userA.cid) //=> \"state-1\"\n\nvar userB = new User();\nconsole.log(userB.cid) //=> \"state-2\"\n```\n\n### isNew `state.isNew()`\n\nHas this state been saved to the server yet? If the state does not yet have an `id` (using `getId()`), it is considered to be new.\n\n### escape `state.escape()`\n\nSimilar to `get`, but returns the HTML-escaped version of a state's attribute. If you're interpolating data from the state into HTML, use `escape` when retrieving attributes to help prevent XSS attacks.\n\n```\nvar hacker = new PersonModel({\n    name: \"<script>alert('xss')</script>\"\n});\n\ndocument.body.innerHTML = hacker.escape('name');\n```\n\n### isValid `state.isValid()`\n\nCheck if the state is currently valid. It does this by calling the state's `validate` method (if you've provided one).\n\n\n### dataTypes  `AmpersandState.extend({ datatypes: myCustomTypes })`\n\nampersand-state defines several built-in datatypes:  `string`, `number`, `boolean`, `array`, `object`, `date`, `state`, or `any`.  Of these, `object`, `array` and `any` allow for a lot of extra flexibility.  However sometimes it may be useful to define your own custom datatypes.  Then you can use these types in the `props` below with all their features (like `required`, `default`, etc).\n\nTo define a type, you generally will provide an object with 4 member functions (though only 2 are usually necessary)  `get`, `set`, `default`, and `compare`.\n\n* `set : function(newVal){};  returns {type : type, val : newVal};`:  Called on every set. Should return an object with two members: `val` and `type`.  If the `type` value does not equal the name of the dataType you defined, a `TypeError` should be thrown.\n* `compare : function(currentVal, newVal, attributeName){}; returns boolean`:  Called on every `set`. Should return `true` if `oldVal` and `newVal` are equal.  Non-equal values will eventually trigger `change` events, unless the state's `set` (not the dataTypes's!) is called with the option `{silent : true}`.\n* `get : function(val){} returns val;`:  Overrides the default getter of this type.  Useful if you want to make defensive copies.  For example, the `date` dataType returns a clone of the internally saved `date` to keep the internal state consistent.\n* `default : function(){} returns val;`:  Returns the default value for this type.\n\n\nFor example, let's say your application uses a special type of date, `JulianDate`.  You'd like to setup this as a type in state, but don't want to just use `any` or `object` as the type.  To define it:\n```javascript\n// Julian Date is a 'class' defined elsewhere:\n// it has an 'equals' method and takes `{julianDays : number}` as a constructor\n\nvar Person = AmpersandState.extend({\n   dataTypes : {\n        julianDate : {\n           // set called every time someone tried to set a property of this datatype\n           set : function(newVal){\n               if(newVal instanceof JulianDate){\n                   return {\n                       val : newVal,\n                       type : 'julianDate'\n                   };\n               }\n               try{\n                   // try to parse it from passed in value:\n                   var newDate = new JulianDate(newVal);\n\n                   return {\n                       val : newDate,\n                       type : 'julianDate'\n                   };\n               }catch(parseError){\n                   // return the value with what we think its type is\n                   return {\n                       val : newVal,\n                       type : typeof newVal\n                   };\n               }\n           },\n           compare : function(currentVal, newVal, attributeName){\n               return currentVal.equals(newVal);\n           }\n       }\n\n   }\n   props : {\n       bornOn : 'julianDate',\n       retiresOn : {\n           type : 'julianDate',\n           required : 'true',\n           default : function(){\n                  // assuming an 'add' function on julian date which returns a new JulianDate\n                  return this.bornOn.add('60','years');\n               }\n           }\n   }\n});\n\nvar person = new Person({ bornOn : new JulianDate({julianDays : 1000}); }\n// this will also work and will build a new JulianDate\nvar person = new Person({bornOn : {julianDays : 1000}});\n\n// will construct a new julian date for us\n// and will also trigger a change event\nperson.bornOn = {julianDays : 1001};\n\n// but this will not trigger a change event since the equals method would return true\nperson.bornOn = {julianDays : 1001};\n\n```\n\n\n### props `AmpersandState.extend({ props: { name: 'string' } })`\n\nThe **`props`** object describes the observable properties of your state class. Always pass `props` to `extend`; never set it on an instance, as it won't define new properties.\n\nProperties can be defined in three different ways:\n\n* As a string with the expected dataType. One of `string`, `number`, `boolean`, `array`, `object`, `date`, or `any`. (Example: `name: 'string'`.) Can also be set to the name of a custom `dataTypes`, if the class defines any.\n* An array of `[dataType, required, default]`\n* An object `{ type: 'string', required: true, default: '' , values: [], allowNull: false, setOnce: false }`\n* `default` will be the value that the property will be set to if it is `undefined` (either by not being set during initialization, or by being explicit set to `undefined`).\n* If `required` is `true`, one of two things will happen\n    * If the property has a `default`, it will start with that value, and revert to it after a call to `unset(propertyName)`.\n    * If the property does not have a `default`, calls to `unset(propertyName)` will throw an error.\n* If `values` array is passed, then you'll be able to change a property to one of those values only.\n* If `setOnce` is `true`, then you'll be able to set property only once.\n    * If the property has a `default`, and you don't set the value initially, the property will be permanently set to the default value.\n    * If the property doesn't have a `default`, and you don't set the value initially, it can be set later, but only once.\n\nTrying to set a property to an invalid type will throw an error.\n\nSee [get](#ampersand-state-get) and [set](#ampersand-state-set) for more information about getting and setting properties.\n\n```javascript\nvar Person = AmpersandState.extend({\n    props: {\n        name: 'string',\n        age: 'number',\n        paying: ['boolean', true, false], // required attribute, defaulted to false\n        type: {\n            type: 'string',\n            values: ['regular-hero', 'super-hero', 'mega-hero']\n        }\n    }\n});\n```\n\n#### reserved prop, session names\n\nThe following should not be used as `prop` names for any state object. This of course includes things based on state such as ampersand-model and ampersand-view.\n\nIf you're consuming an API you don't control, you can re-name keys by overwriting `parse` and `serialize` methods.\n\n`bind`, `changedAttributes`, `cid`, `clear`, `collection`, `constructor`, `createEmitter`, `escape`, `extraProperties`, `get`, `getAttributes`, `getId`, `getNamespace`, `getType`, `hasChanged`, `idAttribute`, `initialize`, `isNew`, `isValid`, `listenTo`, `listenToAndRun`, `listenToOnce`, `namespaceAttribute`, `off`, `on`, `once`, `parent`, `parse`, `previous`, `previousAttributes`, `serialize`, `set`, `stopListening`, `toJSON`, `toggle`, `trigger`, `typeAttribute`, `unbind`, `unset`, `url`\n\n#### defaulting to objects/arrays\n\nYou will get an error if you try to set the default of any property as either an object or array.  This is because those two dataTypes are mutable and passed by reference.  (Thus, if you *did* set a property's default to `['a','b']`, it would return *the same array* on every new instantiation of the state.)\n\nInstead, if you want a property to default to an array or an object, just set `default` to a function, like this:\n\n```javascript\nAmpersandModel.extend({\n    props: {\n        checkpoints: {\n            type: 'array',\n            default: function () { return []; }\n        }\n    }\n});\n```\n\nIt's worth noting that both `array` and `object` have this behavior built-in: they default to empty versions of themselves.  You would only need to do this if you wanted to default to an array/object that wasn't empty.\n\n### session `AmpersandState.extend({ session: { name: 'string' } })`\n\nSession properties are defined and work in exactly the same way as [props](#ampersand-state-props), but generally only exist for the lifetime of the page. They would not typically be persisted to the server, and are not returned by calls to `toJSON()` or `serialize()`.\n\n```javascript\nvar Person = AmpersandState.extend({\n    props: {\n        name: 'string',\n    },\n    session: {\n        isLoggedIn: 'boolean'\n    }\n);\n```\n\n### derived `AmpersandState.extend({ derived: { derivedProperties }})`\n\nDerived properties (also known as computed properties) are properties of the state object that depend on other properties (from `props`, `session`,  or even `derived`) to determine their value. Best demonstrated with an example:\n\n```javascript\nvar Person = AmpersandState.extend({\n    props: {\n        firstName: 'string',\n        lastName: 'string'\n    },\n    derived: {\n        fullName: {\n            deps: ['firstName', 'lastName'],\n            fn: function () {\n                return this.firstName + ' ' + this.lastName;\n            }\n        }\n    }\n});\n\nvar person = new Person({ firstName: 'Phil', lastName: 'Roberts' });\nconsole.log(person.fullName) //=> \"Phil Roberts\"\n\nperson.firstName = 'Bob';\nconsole.log(person.fullName) //=> \"Bob Roberts\"\n```\n\nEach derived property is defined as an object with the following properties:\n\n* `deps` {Array} - An array of property names which the derived property depends on.\n* `fn` {Function} - A function which returns the value of the computed property. It is called in the context of the current object, so that `this` is set correctly.\n* `cache` {Boolean} - Whether to cache the property. Uncached properties are computed everytime they are accessed. Useful if it depends on the current time for example. _Defaults to `true`_.\n\nDerived properties are retrieved and fire `change` events just like any other property. However, they cannot be set directly. Caching ensures that the `fn` function is only run when any of the dependencies change, and `change` events are only fired if the result of calling `fn()` has actually changed.\n\n### children `AmpersandState.extend({ children: { profile: Profile } })`\n\nDefine child state objects to attach to the object. Attributes passed to the constructor or to `set()` will be proxied to the children/collections. Childen's `change` events are proxied to the parent.\n\n```javascript\nvar AmpersandState = require('ampersand-state');\nvar Hat = AmpersandState.extend({\n    props: {\n        color: 'string'\n    }\n});\n\nvar Person = AmpersandState.extend({\n    props: {\n        name: 'string'\n    },\n    children: {\n        hat: Hat\n    }\n});\n\nvar me = new Person({ name: 'Phil', hat: { color: 'red' } });\n\nme.on('all', function (eventName) {\n    console.log('Got event: ', eventName);\n});\n\nconsole.log(me.hat) //=> Hat{color: 'red'}\n\nme.set({ hat: { color: 'green' } });\n//-> \"Got event: change:hat.color\"\n//-> \"Got event: change\"\n\nconsole.log(me.hat) //=> Hat{color: 'green'}\n```\n\n**note:** If you want to be able to swap out and get a `change` event from a child model, don't use `children` instead, define a prop in `props` of type `state`.\n\n`children` and `collections` are not just a property of the parent, they're *part* of the parent. When you create the parent, an instance of any children or collections will be instantiated as part of instantiating the parent, whether they have any data or not.\n\nCalling `.set()` on the parent with a nested object will automatically `set()` them on children and collections too. This is super handy for APIs [like this one](https://developer.github.com/v3/repos/#response) that return nested JSON structures.\n\nAlso, there will be no `change` events triggered if you replace a child with something else after you've instantiated the parent because it's not a true property in the `props` sense. If you need a prop that stores a state instance, define it as such, don't use `children`.\n\nThe distinction is important because without it, the following would be problemmatic:\n\n```\nvar Person = State.extend({\n    props: {\n        child: {\n            type: 'state'\n        }\n    }\n});\n\nvar person = new Person()\n\n// throws type error because `{}` isn't a state object\nperson.child = {};\n// should this work? What should happen if the `child` prop isn't defined yet?\nperson.set({child: {name: 'mary'}});\n```\n\nSo, while having `children` in addition to props of type `state` may feel redundant they both exist to help disambiguate how they're meant to be used.\n\n### collections `AmpersandState.extend({ collections: { widgets: Widgets } })`\n\nDefine child collection objects to attach to the object. Attributes passed to the constructor or to `set()` will be proxied to the collections.\n\n**Note:** Currently, events *don't* automatically proxy from collections to parent. This is for efficiency reasons. But there are ongoing discussions about how to best handle this.\n\n```javascript\nvar State = require('ampersand-state');\nvar Collection = require('ampersand-collection');\n\nvar Widget = State.extend({\n    props: {\n        name: 'string',\n        funLevel: 'number'\n    }\n});\n\nvar WidgetCollection = Collection.extend({\n    model: Widget\n});\n\nvar Person = AmpersandState.extend({\n    props: {\n        name: 'string'\n    },\n    collections: {\n        widgets: WidgetCollection\n    }\n});\n\nvar me = new Person({\n    name: 'Henrik',\n    widgets: [\n        { name: 'rc car', funLevel: 8 },\n        { name: 'skis', funLevel: 11 }\n    ]\n});\n\nconsole.log(me.widgets.length); //=> 2\nconsole.log(me.widgets instanceof WidgetCollection); //=> true\n```\n\n\n### parse\n\n**parse** is called when the state is initialized, allowing the attributes to be modified, remapped, renamed, etc., before they are actually applied to the state. In ampersand-state, `parse` is only called when the state is initialized, and *only* if `{ parse: true }` is passed to the constructor's options:\n\n```javascript\nvar Person = AmpersandState.extend({\n    props: {\n        id: 'number',\n        name: 'string'\n    },\n\n    parse: function (attrs) {\n        attrs.id = attrs.personID; //remap an oddly named attribute\n        delete attrs.personID;\n\n        return attrs;\n    }\n});\n\nvar me = new Person({ personID: 123, name: 'Phil' },{ parse: true});\n\nconsole.log(me.id) //=> 123\nconsole.log(me.personID) //=> undefined\n```\n\n**parse** is arguably more useful in ampersand-model, where data typically comes from the server.\n\n### serialize `state.serialize()`\n\nSerialize the state object into a plain object, ready for sending to the server (typically called via [toJSON](#ampersand-state-tojson)). Of the state's properties, only `props` is returned, `session` and `derived` are omitted. Will also serialize any `children` or `collections` by calling their serialize methods.\n\n\n### get `state.get(attribute); state[attribute]; state.firstName`\n\nGet the current value of an attribute from the state object. Attributes can be accessed directly, or a call to the Backbone style `get`. So these are all equivalent:\n\n```javascript\nperson.get('firstName');\nperson['firstName'];\nperson.firstName\n```\n\nGet will retrieve `props`, `session` or `derived` properties all in the same way.\n\n### set `state.set(attributes, [options]); state.firstName = 'Henrik';`\n\nSets an attribute, or multiple attributes, on the state object. If any of the state object's attributes change, it will trigger a `\"change\"` event. Change events for specific attributes are also triggered, which you can listen to as well. For example: `\"change:firstName\"` and `\"change:content\"`. If the changes update any `derived` properties on the object, their values will be updated, and change events fired as well.\n\nAttributes can be set directly, or via a call to the backbone style `set` (useful if you wish to update multiple attributes at once):\n\n```javascript\nperson.set({firstName: 'Phil', lastName: 'Roberts'});\nperson.set('firstName', 'Phil');\nperson.firstName = 'Phil';\n```\n\nPossible options (when using `state.set()`):\n\n* `silent` {Boolean} - prevents triggering of any change events as a result of the set operation.\n* `unset` {Boolean} - `unset` the attributes keyed in the attributes object instead of setting them.\n\n### unset `state.unset(attribute|attributes[], [options])`\n\nClear the named attribute or an array of named attributes from the state object. Fires a `\"change\"` event and a `\"change:attributeName\"` event unless `silent` is passed as an option.\n\nIf the attribute being unset is `required` and has a `default` value as defined in either `props` or `session`, it will be set to that value, otherwise it will be `undefined`.\n\n```javascript\n// unset a single attribute\nperson.unset('firstName')\n```\n\n```javascript\n// unset multiple attributes\nperson.unset(['firstName', 'lastName'])\n```\n\n### clear `state.clear([options])`\n\nClear all the attributes from the state object, by calling the `unset` function for each attribute, with the options provided.\n\n```javascript\nperson.clear()\n```\n\n### toggle `state.toggle('a')`\n\nShortcut to toggle boolean properties, or cycle through “ENUM” type properties with a `values` array in their definition. Fires `\"change\"` events, as you would expect from `set()`.\n\n```javascript\nvar Person = AmpersandState.extend({\n    props: {\n        active: 'boolean',\n        color: {\n            type: 'string',\n            values: ['red', 'green', 'blue']\n        }\n    }\n});\n\nvar me = new Person({ active: true, color: 'green' });\n\nme.toggle('active');\nconsole.log(me.active) //=> false\n\nme.toggle('color');\nconsole.log(me.color) //=> 'blue'\n\nme.toggle('color');\nconsole.log(me.color) //=> 'red'\n```\n\n\n### previousAttributes `state.previousAttributes()`\n\nReturn a copy of the object's previous attributes (the state before the last `\"change\"` event). Useful for getting a diff between versions of a state, or getting back to a valid state after an error occurs.\n\n\n### hasChanged `state.hasChanged([attribute])`\n\nDetermine if the state has been modified since the last `\"change\"` event. If an attribute name is passed, determine if that one attribute has changed.\n\n**note:** that this will only be `true` if checked inside a handler while the various `change` events are firing. Once the change events are done this will always return `false`. This has nothing to do with determining whether a property has changed since the last time it was saved to the server.\n\n### changedAttributes `state.changedAttributes([objectToDiff])`\n\nReturn an object containing all the attributes that have changed, or `false` if there are no changed attributes. Useful for determining what parts of a view need to be updated and/or what attributes need to be persisted to the server. Unset attributes will be set to undefined.  You can also pass an attributes object to diff against the state, determining if there *would be* a change.\n\n**note:** that if passing an attributes object to diff against, only changes to properties defined on the model will be detected. This means that changes to children or collections will *not* be returned as changes by this method.\n\n**note:** that this will only return values if checked inside a handler while the various `change` events are firing. Once the change events are done this will always be return an empty object. This has nothing to do with determining which properties have been changed since the last time it was saved to the server.\n\n### toJSON `state.toJSON()`\n\nReturn a shallow copy of the state's attributes for JSON stringification. This can be used for persistence, serialization, or augmentation, before being sent to the server. The name of this method is a bit confusing, as it doesn't actually return a JSON string — but I'm afraid that it's the way that the JavaScript API for `JSON.stringify` works.\n\nCalls [serialize](#ampersand-state-serialize) to determine which values to return in the object. Will be called implicitly by `JSON.stringify`.\n\n```javascript\nvar me = new Person({ firstName: 'Phil', lastName: 'Roberts' });\n\nme.toJSON() //=> { firstName: 'Phil', lastName: 'Roberts' }\n\n//JSON.stringify implicitly calls toJSON:\nJSON.stringify(me) //=> \"{\\\"firstName\\\":\\\"Phil\\\",\\\"lastName\\\":\\\"Roberts\\\"}\"\n```\n\n### getAttributes `state.getAttributes([options, raw])`\n\nReturns a shallow copy of the state's attributes while only including the types (props, session, derived) specified by the `options` parameter. The desired keys should be set to `true` on `options` (`props`, `session`, `derived`) if attributes of that type should be returned by `getAttributes`.\n\nThe second parameter, `raw`, is a boolean that specifies whether returned values should be the raw value or should instead use the getter associated with its data type. If you are using `getAttributes` to pass data to a template, most of the time you will not want to use the `raw` parameter, since you will want to take advantage of any built-in and custom data types on your state instance.\n\n```javascript\nvar Person = AmpersandState.extend({\n  props: {\n      firstName: 'string',\n      lastName: 'string'\n  },\n  session: {\n    lastSeen: 'date',\n    active: 'boolean'\n  },\n  derived: {\n    fullName: {\n      deps: ['firstName', 'lastName'],\n      fn: function () {\n        return this.firstName + ' ' + this.lastName;\n      }\n    }\n  }\n});\n\nvar me = new Person({ firstName: 'Luke', lastName: 'Karrys', active: true, lastSeen: 1428430444479 });\n\nme.getAttributes({derived: true}) //=> { fullName: 'Luke Karrys' }\n\nme.getAttributes({session: true}) //=> { active: true, lastSeen: Tue Apr 07 2015 11:14:04 GMT-0700 (MST) }\nme.getAttributes({session: true}, true) //=> { active: true, lastSeen: 1428430444479 }\n\nme.getAttributes({\n  props: true,\n  session: true,\n  derived: true\n}) //=> { firstName: 'Luke', lastName: 'Karrys', active: true, lastSeen: Tue Apr 07 2015 11:14:04 GMT-0700 (MST), fullName: 'Luke Karrys' }\n```\n\n<!-- starthide -->\n## Credits\n\n[@HenrikJoreteg](http://twitter.com/henrikjoreteg)\n\n## License\n\nMIT\n<!-- endhide -->\n",
  "readmeFilename": "README.md",
  "_id": "ampersand-state@4.5.6",
  "_from": "ampersand-state@^4.5.2"
}
