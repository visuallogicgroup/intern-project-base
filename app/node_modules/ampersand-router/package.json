{
  "name": "ampersand-router",
  "description": "Clientside router with fallbacks for browsers that don't support pushState. Mostly lifted from Backbone.js.",
  "version": "3.0.2",
  "author": {
    "name": "Henrik Joreteg",
    "email": "henrik@andyet.net"
  },
  "browserify": {
    "transform": [
      "ampersand-version"
    ]
  },
  "bugs": {
    "url": "https://github.com/ampersandjs/ampersand-router/issues"
  },
  "dependencies": {
    "ampersand-class-extend": "^1.0.0",
    "ampersand-events": "^1.1.1",
    "ampersand-version": "^1.0.0",
    "lodash.assign": "^3.0.0",
    "lodash.bind": "^3.1.0",
    "lodash.isfunction": "^3.0.2",
    "lodash.isregexp": "^3.0.1",
    "lodash.result": "^3.0.0"
  },
  "devDependencies": {
    "browserify": "^4.1.10",
    "jshint": "^2.5.3",
    "lodash.pick": "^3.1.0",
    "lodash.foreach": "^3.0.2",
    "phantomjs": "^1.9.7-15",
    "precommit-hook": "^1.0.7",
    "run-browser": "^1.3.1",
    "tap-spec": "^0.2.0",
    "tape": "^2.13.2",
    "tape-run": "^0.1.1"
  },
  "homepage": "https://github.com/ampersandjs/ampersand-router",
  "keywords": [
    "clientside",
    "router",
    "history"
  ],
  "license": "MIT",
  "main": "ampersand-router.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/ampersandjs/ampersand-router"
  },
  "scripts": {
    "start": "run-browser test/index.js",
    "test": "browserify test/index.js | tape-run | tap-spec"
  },
  "readme": "# ampersand-router\n\nClientside router with fallbacks for browsers that don't support pushState. Mostly lifted from [Backbone.js](http://backbonejs.org/#Router).\n\nAmpersand-router also adds a `redirectTo` method which is handy for doing \"internal\" redirects without breaking backbutton functionality in the browser.\n\n<!-- starthide -->\nPart of the [Ampersand.js toolkit](http://ampersandjs.com) for building clientside applications.\n<!-- endhide -->\n\n## install\n\n```\nnpm install ampersand-router\n```\n\n<!-- starthide -->\n## example\n\nIn this example the router is trigger a `newPage` event along with the instance of a page. It is up to your application to listen for this event on the router and then do something with the page instance.\n\nThis is helpful when paired with the [`ampersand-view-switcher#set`](https://github.com/AmpersandJS/ampersand-view-switcher#set-switchersetviewinstance) method to ensure that the page instance is rendered into the correct container and it gets cleaned up properly via its `remove` method when a new page gets triggered by the router. Check out how the `ampersand` cli accomplishes this within its [router](https://github.com/AmpersandJS/ampersand/blob/41ff011c43e4d3adab06b4b1941583034d58195f/template/shared/client/router.js#L24-L26) and [view-switcher](https://github.com/AmpersandJS/ampersand/blob/41ff011c43e4d3adab06b4b1941583034d58195f/template/shared/client/views/main.js#L53).\n\n```javascript\nvar Router = require('ampersand-router');\n\n\nmodule.exports = Router.extend({\n    routes: {\n        '': 'home',\n        'users/:id': 'userDetail',\n        'info': 'info'\n    },\n\n    // ------- ROUTE HANDLERS ---------\n    home: function () {\n        this.trigger('newPage', new HomePage());\n    },\n\n    // redirect example\n    userDetail: function (id) {\n        var user = app.users.get(id);\n        if (user) {\n            this.trigger('newPage', new HomePage());\n        } else {\n            this.redirectTo('users');\n        }\n    }\n\n    ...\n});\n```\n<!-- endhide -->\n\n## API Reference\n\n### extend `AmpersandRouter.extend(properties)`\n\nGet started by creating a custom router class. Define actions that are triggered when certain URL fragments are matched, and provide a [routes](#ampersand-router-routes) hash that pairs routes to actions. Note that you'll want to avoid using a leading slash in your route definitions:\n\n```javascript\nvar AppRouter = AmpersandRouter.extend({\n\n  routes: {\n    \"help\":                 \"help\",    // #help\n    \"search/:query\":        \"search\",  // #search/kiwis\n    \"search/:query/p:page\": \"search\"   // #search/kiwis/p7\n  },\n\n  help: function() {\n    //...\n  },\n\n  search: function(query, page) {\n    //...\n  }\n\n});\n```\n\n### routes `router.routes`\n\nThe routes hash maps URLs with parameters to functions on your router (or just direct function definitions, if you prefer), similar to the [View](#ampersand-view)'s [events hash](#ampersand-view-events). Routes can contain parameter parts, `:param`, which match a single URL component between slashes; and splat parts `*splat`, which can match any number of URL components. Part of a route can be made optional by surrounding it in parentheses `(/:optional)`.\n\nFor example, a route of `\"search/:query/p:page\"` will match a fragment of `#search/obama/p2`, passing `\"obama\"` and `\"2\"` to the action.\n\nA route of `\"file/*path\"` will match `#file/nested/folder/file.txt`, passing `\"nested/folder/file.txt\"` to the action.\n\nA route of `\"docs/:section(/:subsection)\"` will match #docs/faq and #docs/faq/installing, passing `\"faq\"` to the action in the first case, and passing `\"faq\"` and `\"installing\"` to the action in the second.\n\nTrailing slashes are treated as part of the URL, and (correctly) treated as a unique route when accessed. `docs` and `docs/` will fire different callbacks. If you can't avoid generating both types of URLs, you can define a `\"docs(/)\"` matcher to capture both cases.\n\nWhen the visitor presses the back button, or enters a URL, and a particular route is matched, the name of the action will be fired as an event, so that other objects can listen to the router, and be notified. In the following example, visiting `#help/uploading` will fire a `route:help` event from the router.\n\n```javascript\nroutes: {\n  \"help/:page\":         \"help\",\n  \"download/*path\":     \"download\",\n  \"folder/:name\":       \"openFolder\",\n  \"folder/:name-:mode\": \"openFolder\"\n}\n\nrouter.on(\"route:help\", function(page) {\n  ...\n});\n```\n\n### constructor / initialize `new Router([options])`\n\nWhen creating a new router, you may pass its routes hash directly as the `routes` option, if you choose. All options will also be passed to your `initialize` function, if defined.\n\n### route `router.route(route, name, [callback])`\n\nManually create a route for the router, The `route` argument may be a routing string or regular expression. Each matching capture from the route or regular expression will be passed as an argument to the callback. The `name` argument will be triggered as a `\"route:name\"` event whenever the route is matched. If the `callback` argument is omitted `router[name]` will be used instead. Routes added later may override previously declared routes.\n\n```javascript\ninitialize: function(options) {\n\n  // Matches #page/10, passing \"10\"\n  this.route(\"page/:number\", \"page\", function(number){ ... });\n\n  // Matches /117-a/b/c/open, passing \"117-a/b/c\" to this.open\n  this.route(/^(.*?)\\/open$/, \"open\");\n\n},\n\nopen: function(id) { ... }\n```\n\n### navigate `router.navigate(fragment, [options])`\n\nWhenever you reach a point in your application that you'd like to save as a URL, call *navigate* in order to update the URL. Route function will be called by default, but if you want to prevent it, you can set the `trigger` option to `false`. To update the URL without creating an entry in the browser's history, set the `replace` option to `true`.\n\n```javascript\nopenPage: function(pageNumber) {\n  this.document.pages.at(pageNumber).open();\n  this.navigate(\"page/\" + pageNumber);\n}\n\n// Or ...\n\napp.navigate(\"help/troubleshooting\", {trigger: false});\n\n// Or ...\n\napp.navigate(\"help/troubleshooting\", {replace: true});\n```\n\n### reload `router.reload()`\n\nAllows you to re-navigate to the same page.  Re-runs the route handler\nfor the current url.\n\n### redirectTo `router.redirectTo(fragment)`\n\nSometimes you want to be able to redirect to a different route in your application without adding an entry in the browser's history. RedirectTo is just a shorthand for calling [navigate](#ampersand-router-navigate) with both `trigger` and `replace` set to `true`.\n\n```javascript\nvar AppRouter = AmpersandRouter.extend({\n    routes: {\n        'login': 'login',\n        'dashboard': 'dashboard'\n    },\n\n    dashboard: function () {\n        if (!app.me.loggedIn) return this.redirectTo('login');\n\n        // show dashboard page...\n    }\n});\n```\n\n### execute `router.execute(callback, args)`\n\nThis method is called internally within the router, whenever a route matches and its corresponding callback is about to be executed. Override it to perform custom parsing or wrapping of your routes, for example, to parse query strings before handing them to your route callback, like so:\n\n```javascript\nvar Router = AmpersandRouter.extend({\n  execute: function(callback, args) {\n    args.push(parseQueryString(args.pop()));\n    if (callback) callback.apply(this, args);\n  }\n});\n```\n\n### history.start `router.history.start([options])`\n\nAmpersandRouter automatically requires and instantiates a single ampersand-history object. AmpersandHistory serves as a global router (per frame) to handle hashchange events or pushState, match the appropriate route, and trigger callbacks. You shouldn't ever have to create one of these yourself since ampersand-router already contains one.\n\nWhen all of your Routers have been created, and all of the routes are set up properly, call `router.history.start()` on one of your routers to begin monitoring hashchange events, and dispatching routes. Subsequent calls to `history.start()` will throw an error, and `router.history.started()` is a boolean value indicating whether it has already been called.\n\nSupported options:\n\n* **pushState** {Boolean} - HTML5 pushState is turned on by default. However if you want to indicate that you don't want to use it in your application, you can add `{pushState: false}` to the options. __Defaults to true__\n* **hashChange** {Boolean} - If you'd like to use pushState, but have browsers that don't support it natively use full page refreshes instead, you can add `{hashChange: false}` to the options. __Defaults to true__\n* **root** {String} - If your application is not being served from the root url `/` of your domain, be sure to tell History where the root really is, as an option: `router.history.start({root: \"/public/search/\"})`. __Defaults to `/`__\n* **silent** {Boolean} - If the server has already rendered the entire page, and you don't want the initial route to trigger when starting History, pass `silent: true`. __Defaults to false__\n\nWhen called, if a route succeeds with a match for the current URL, `router.history.start()` returns `true`. If no defined route matches the current URL, it returns `false`.\n\n\n<!-- starthide -->\n## credits\n\nAll credit goes to Jeremy Ashkenas and the rest of the Backbone.js authors.\n\nIf you like this follow [@HenrikJoreteg](http://twitter.com/henrikjoreteg) on twitter.\n\n## license\n\nMIT\n<!-- endhide -->\n",
  "readmeFilename": "README.md",
  "_id": "ampersand-router@3.0.2",
  "_from": "ampersand-router@^3.0.1"
}
