{
  "name": "ampersand-dom-bindings",
  "description": "Takes binding declarations and returns key-tree-store of functions that can be used to apply those bindings.",
  "version": "3.5.0",
  "author": {
    "name": "'Henrik Joreteg'",
    "email": "henrik@andyet.net"
  },
  "browserify": {
    "transform": [
      "ampersand-version"
    ]
  },
  "bugs": {
    "url": "https://github.com/ampersandjs/ampersand-dom-bindings/issues"
  },
  "dependencies": {
    "ampersand-dom": "^1.2.5",
    "ampersand-version": "^1.0.0",
    "is-array": "^1.0.1",
    "key-tree-store": "^1.2.0",
    "matches-selector": "^1.0.0"
  },
  "devDependencies": {
    "browserify": "^5.11.0",
    "jshint": "^2.5.6",
    "phantomjs": "^1.9.7-15",
    "precommit-hook": "^1.0.7",
    "run-browser": "~1.3.1",
    "tap-spec": "^0.2.0",
    "tape": "^2.13.2",
    "tape-run": "~0.1.1"
  },
  "homepage": "https://github.com/ampersandjs/ampersand-dom-bindings",
  "keywords": [
    "dom",
    "bindings",
    "browser"
  ],
  "license": "MIT",
  "main": "ampersand-dom-bindings.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/ampersandjs/ampersand-dom-bindings"
  },
  "scripts": {
    "start": "run-browser test/index.js",
    "test": "browserify test/index.js | tape-run | tap-spec"
  },
  "testling": {
    "files": "test/*.js",
    "browsers": [
      "ie/8..latest",
      "firefox/17..latest",
      "firefox/nightly",
      "chrome/22..latest",
      "chrome/canary",
      "opera/12..latest",
      "opera/next",
      "safari/5.1..latest",
      "ipad/6.0..latest",
      "iphone/6.0..latest",
      "android-browser/4.2..latest"
    ]
  },
  "readme": "# ampersand-dom-bindings\n\n<!-- starthide -->\nPart of the [Ampersand.js toolkit](http://ampersandjs.com) for building clientside applications.\n<!-- endhide -->\n\nTakes binding declarations as described below and returns [key-tree-store](https://github.com/HenrikJoreteg/key-tree-store) of functions that can be used to apply those bindings to a DOM tree.\n\n[ampersand-view](http://ampersandjs.com/docs#ampersand-view) use this for declarative bindings.\n\nThe returned functions should be called with these arguments: The root element, the current value of the property, and a name for the binding types where that is relevant.\n\n## install\n\n```\nnpm install ampersand-dom-bindings\n```\n\n## Binding types\n\n### text\n\nsets/maintains `textContent` of selected element. treats `undefined`, `null`, and `NaN` as `''`\n\n```js\n'model.key': {\n    type: 'text',\n    selector: '.someSelector' // or hook\n}\n```\n\n### class\n\nsets and maintains single class as string that matches value of property\n- handles removing previous class if there was one\n- treats `undefined`, `null`, and `NaN` as `''` (empty string).\n\n```js\n'model.key': {\n    type: 'class',\n    selector: // or hook\n}\n```\n\n### attribute \nsets the whole attribute to match value of property. treats `undefined`, `null`, and `NaN` as `''` (empty string). `name` can also be an array to set multiple attributes to the same value.\n    \n```js\n'model.key': {\n    type: 'attribute',\n    selector: '#something', // or hook\n    name: 'width'\n}\n```\n\n### value\n\nsets the value of the element to match value of the property. works well for `input`, `select`, and `textarea` elements. treats `undefined`, `null`, and `NaN` as `''` (empty string).\n\n**note**: The binding will only be applied if the element is not currently in focus. This is done by checking to see if the element is the `document.activeElement` first. The reason it works this way is because if you've set up two-way data bindings you get a circular event: the input changes, which sets the bound model property, which in turn updates the value of the input. This might sound OK but results in the cursor always jumping to the end of the input/textarea. So if you're editing the middle of a bound text field, the cursor keeps jumping to the end. We avoid this by making sure it's not already in focus thus avoiding the bad loop.\n    \n```js\n'model.key': {\n    type: 'value',\n    selector: '#something', // or hook\n}\n```\n\n### booleanClass\n\nadd/removes class based on boolean interpretation of property name. `name`, `yes`, or `no` can also be an array of class names where all the values will be toggled.\n\n```js\n'model.active': {\n    type: 'booleanClass',\n    selector: '#something', // or hook\n    // to specify name of class to toggle (if different than key name)\n    // you could either specify a name\n    name: 'active'\n    // or a yes/no case\n    yes: 'active',\n    no: 'not-active'\n}\n```\n\n### booleanAttribute\n\ntoggles whole attribute on the element (think `checked`) based on boolean interpretation of property name. `name` can also be an array of attribute names where all the values will be toggled.\n\n```js\n'model.isAwesome': {\n    type: 'booleanAttribute',\n    selector: '#something', // or hook\n    // to specify name of attribute to toggle (if different than key name)\n    // you could either specify a name\n    name: 'checked'\n    // or a yes/no case\n    yes: 'data-is-awesome',\n    no: 'data-is-not-awesome'\n}\n```\n\n### toggle\n\ntoggles visibility (using display: none by default) of entire element based on boolean interpretation of property.\n\n```js\n// simple show/hide of single element\n'model.key': {\n    type: 'toggle',\n    selector: '#something' // or hook\n}\n\n// toggle visibility property instead\n'model.key': {\n    type: 'toggle',\n    selector: '#something', // or hook\n    mode: 'visibility'\n}\n\n// show/hide where true/false show different things\n'model.key': {\n    type: 'toggle',\n    yes: '#true_case',\n    no: '#false_case'\n}\n```\n\n### switch\n\nToggles existence of multiple items based on value of property.\n\n```js\n'model.activetab': {\n    type: 'switch',\n    cases: {\n        'edit': '#edit_tab',\n        'new': '#new_tab',\n        'details': '#details_tab'\n    }\n}\n```\n\n### switchClass\n\nToggles existence of a class on multiple elements based on value of property.\n\n```js\n'model.key': {\n    type: 'switchClass',\n    name: 'is-active',\n    cases: {\n        'edit': '#edit_tab',\n        'new': '#new_tab',\n        'details': '#details_tab'\n    }\n}\n```\n\n### switchAttribute\n\nSets attribute(s) on matching elements based on the value of a property matching the case.\n\n```js\n'model.key': {\n    type: 'switchAttribute',\n    selector: 'a', // or hook\n    name: 'href',  // name defaults to the property name (e.g. 'key' from 'model.key' in this example)\n    cases: {\n        value1: '/foo',\n        value2: '/bar'\n    }\n}\n```\n\nYou can also specify multiple attributes by using an object as the case value. The object keys are used instead of the `name` option.\n\n```js\n'model.key': {\n    type: 'switchAttribute',\n    selector: 'a', // or hook\n    cases: {\n        value1: { href: '/foo', name: 'foo' },\n        value2: { href: '/bar', name: 'bar' }\n    }\n}\n```\n\n### innerHTML\n\nrenders innerHTML, can be a string or DOM, based on property value of model\n\n```js\n'model.key': {\n    type: 'innerHTML',\n    selector: '#something' // or hook\n}\n```\n\n### custom functions\n\n`type` can also be a function. It will be run for each matching `el` with the\n`value` and `previousValue` of the property. The function is bound to the view\ndeclaring the bindings, so `this` refers to the view.\n\n```js\n'model.key': {\n    type: function (el, value, previousValue) {\n        // Do something custom to el\n        // using value and/or previousValue\n    },\n    selector: '#something', // or hook\n}\n```\n\n## Handling multiple bindings for a given key\n\nIf given an array, then treat each contained item as separate binding\n\n```js\n'model.key': [\n    {\n        type: 'booleanClass',\n        selector: '#something', // or hook\n        name: 'active' // (optional) name of class to toggle if different than key name\n    },\n    {\n        type: 'attribute',\n        selector: '#something', // or hook\n        name: 'width'\n    }\n]\n```\n\nThe `attribute`, `booleanAttribute` and `booleanClass` types also accept an array for the `name` property (and `yes`/`no` for `booleanClass`). All the values in the array will be set the same as if each were bound separately.\n\n```js\n'model.key': {\n    // Also works with booleanAttribute and booleanClass\n    type: 'attribute',\n    selector: '#avatar',\n    // Both height and width will be bound to model.key\n    name: ['height', 'width']\n}\n```\n\n\n## binding using `data-hook` attribute\n\nWe've started using this convention a lot, rather than using classes and IDs in JS to select elements within a view, we use the `data-hook` attribute. This lets designers edit templates without fear of breaking something by changing a class. It works wonderfully, but the only thing that sucks about that is the syntax of attribute selectors: `[data-hook=some-hook]` is a bit annoying to type a million types, and also in JS-land when coding and we see `[` we always assume arrays.\n\nSo for each of these bindings you can either use `selector` or `hook`, so these two would be equivalent:\n\n```js\n'model.key': {\n    selector: '[data-hook=my-element]'\n}\n\n'model.key': {\n    hook: 'my-element'\n}\n\n```\n\n## handling simplest cases: text\n\n```js\n'model.key': '#something' // creates `text` binding for that selector and property\n\n// `type` defaults to `text` so we can also do\n'model.key': {\n    hook: 'hook-name'\n}\n```\n\n\n## real life example\n\n```js\nvar View = require('ampersand-view');\nvar templates = require('../templates');\n\n\nmodule.exports = View.extend({\n    template: templates.includes.app,\n    bindings: {\n        'model.client_name': {\n            hook: 'name'\n        },\n        'model.logo_uri': {\n            type: 'attribute',\n            name: 'src',\n            hook: 'icon'\n        }\n    }\n});\n```\n\n## other benefits\n\nPreviously after having given views the ability to have their own properties (since view inherits from state) it was awkward to bind those to the DOM. Also, for binding things that were not just `this.model` the syntax had to change. \n\nNow this is fairly simple/obvious:\n\n```js\nmodule.exports = View.extend({\n    template: templates.includes.app,\n    props: {\n        activetab: 'string',\n        person: 'state',\n        meeting: 'state'\n    },\n    bindings: {\n        // for the property that's directly on the view\n        'activetab': {\n            type: 'switch',\n            case: {\n                'edit': '#edit_tab',\n                'new': '#new_tab',\n                'details': '#details_tab'\n            }\n        },\n        // this one is for one model\n        'person.full_name': '[data-hook=name]',\n        // this one is for another model\n        'meeting.subject': '[data-hook=subject]'\n    }\n});\n```\n\n## changelog\n\n- 3.3.1 - Fix issues with yes/no handling in boolean class. Add lots of tests.\n\n## license\n\nMIT\n",
  "readmeFilename": "README.md",
  "_id": "ampersand-dom-bindings@3.5.0",
  "_from": "ampersand-dom-bindings@^3.5.0"
}
